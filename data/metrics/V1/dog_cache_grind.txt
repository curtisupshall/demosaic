==23082== Cachegrind, a cache and branch-prediction profiler
==23082== Copyright (C) 2002-2017, and GNU GPL'd, by Nicholas Nethercote et al.
==23082== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info
==23082== Command: ./metric.exe
==23082==
--23082-- warning: L3 cache found, using its data for the LL simulation.
==23082==
==23082== I   refs:      48,002,349
==23082== I1  misses:           973
==23082== LLi misses:           967
==23082== I1  miss rate:       0.00%
==23082== LLi miss rate:       0.00%
==23082==
==23082== D   refs:      16,040,713  (14,853,881 rd   + 1,186,832 wr)
==23082== D1  misses:        21,946  (    21,062 rd   +       884 wr)
==23082== LLd misses:        21,026  (    20,352 rd   +       674 wr)
==23082== D1  miss rate:        0.1% (       0.1%     +       0.1%  )
==23082== LLd miss rate:        0.1% (       0.1%     +       0.1%  )
==23082==
==23082== LL refs:           22,919  (    22,035 rd   +       884 wr)
==23082== LL misses:         21,993  (    21,319 rd   +       674 wr)
==23082== LL miss rate:         0.0% (       0.0%     +       0.1%  )

--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         8388608 B, 64 B, 16-way associative
Command:          ./metric.exe
Data file:        cachegrind.out.23082
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:
User annotated:
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir         I1mr ILmr Dr         D1mr   DLmr   Dw        D1mw DLmw
--------------------------------------------------------------------------------
48,002,349  973  967 14,853,881 21,062 20,352 1,186,832  884  674  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir         I1mr ILmr Dr         D1mr   DLmr   Dw        D1mw DLmw  file:function
--------------------------------------------------------------------------------
47,836,048   28   28 14,809,402 18,282 18,281 1,169,702    1    0  /tmp/demosaic440/decode.c:main
    56,525   10   10     13,788  1,029    863        16    3    0  ???:_dl_addr

--------------------------------------------------------------------------------
-- Auto-annotated source: /tmp/demosaic440/decode.c
--------------------------------------------------------------------------------
Ir        I1mr ILmr Dr        D1mr  DLmr  Dw     D1mw DLmw

-- line 25 ----------------------------------------
        .    .    .         .     .     .      .    .    .      uint32_t imageSize;
        .    .    .         .     .     .      .    .    .      int32_t xResolution;
        .    .    .         .     .     .      .    .    .      int32_t yResolution;
        .    .    .         .     .     .      .    .    .      uint32_t colorsUsed;
        .    .    .         .     .     .      .    .    .      uint32_t colorsImportant;
        .    .    .         .     .     .      .    .    .  } BMPInfoHeader;
        .    .    .         .     .     .      .    .    .  #pragma pack(pop)
        .    .    .         .     .     .      .    .    .
        3    0    0         0     0     0      1    0    0  int main() {
        4    0    0         0     0     0      2    1    0      FILE *fp = fopen("./encoded.bmp", "rb");
        2    0    0         1     0     0      0    0    0      if (!fp) {
        .    .    .         .     .     .      .    .    .          printf("Error opening file.\n");
        .    .    .         .     .     .      .    .    .          return 1;
        .    .    .         .     .     .      .    .    .      }
        .    .    .         .     .     .      .    .    .
        .    .    .         .     .     .      .    .    .      BMPHeader header;
        .    .    .         .     .     .      .    .    .      BMPInfoHeader infoHeader;
        .    .    .         .     .     .      .    .    .
        .    .    .         .     .     .      .    .    .      // Read the BMP header
        7    1    1         1     0     0      1    0    0      fread(&header, sizeof(BMPHeader), 1, fp);
        7    1    1         1     0     0      1    0    0      fread(&infoHeader, sizeof(BMPInfoHeader), 1, fp);
        .    .    .         .     .     .      .    .    .
        .    .    .         .     .     .      .    .    .      // Check if it's a valid BMP file
        3    0    0         1     0     0      0    0    0      if (header.type != 0x4D42) {
        .    .    .         .     .     .      .    .    .          printf("Invalid BMP file.\n");
        .    .    .         .     .     .      .    .    .          fclose(fp);
        .    .    .         .     .     .      .    .    .          return 1;
        .    .    .         .     .     .      .    .    .      }
        .    .    .         .     .     .      .    .    .
        .    .    .         .     .     .      .    .    .      // Check if it's a 24-bit BMP file
        3    1    1         1     0     0      0    0    0      if (infoHeader.bitDepth != 24) {
        .    .    .         .     .     .      .    .    .          printf("Unsupported bit depth. Only 24-bit BMP is supported.\n");
        .    .    .         .     .     .      .    .    .          fclose(fp);
        .    .    .         .     .     .      .    .    .          return 1;
        .    .    .         .     .     .      .    .    .      }
        .    .    .         .     .     .      .    .    .
        .    .    .         .     .     .      .    .    .      // Calculate the row size in bytes (including padding)
        7    0    0         1     0     0      1    0    0      uint32_t rowSize = ((infoHeader.width * 3 + 3) & ~3);
        .    .    .         .     .     .      .    .    .
        .    .    .         .     .     .      .    .    .      // Allocate memory for the pixel data
        6    1    1         2     0     0      2    0    0      uint8_t *pixels = (uint8_t*)malloc(rowSize * infoHeader.height);
        .    .    .         .     .     .      .    .    .
        .    .    .         .     .     .      .    .    .      // Read the pixel data
        9    0    0         4     0     0      1    0    0      fread(pixels, rowSize * infoHeader.height, 1, fp);
        .    .    .         .     .     .      .    .    .
        3    0    0         1     0     0      1    0    0      fclose(fp);
        .    .    .         .     .     .      .    .    .
        .    .    .         .     .     .      .    .    .      uint8_t *px;
        .    .    .         .     .     .      .    .    .
        .    .    .         .     .     .      .    .    .      int y, x;
        .    .    .         .     .     .      .    .    .      // Access pixel values
    1,916    2    2     1,148     0     0      1    0    0      for (y = 2; y < infoHeader.height - 2; y++) {
  487,432    1    1   291,848     0     0    382    0    0          for (x = 2; x < infoHeader.width - 2; x ++) {
        .    .    .         .     .     .      .    .    .              // Gr pixel
1,164,336    0    0   388,112     0     0 97,028    0    0              px = &pixels[y * rowSize + x * 3];
        .    .    .         .     .     .      .    .    .
        .    .    .         .     .     .      .    .    .              // Red channel derived from left and right pixels
3,687,064    2    2 1,067,308     0     0 97,028    0    0              px[RED] = (pixels[y * rowSize + ((x - 1) * 3) + RED] + pixels[y * rowSize + ((x + 1) * 3) + RED]) / 2;
        .    .    .         .     .     .      .    .    .
        .    .    .         .     .     .      .    .    .              // Blue channel derived from above and below pixels
3,493,008    1    1 1,067,308     0     0 97,028    0    0              px[BLUE] = (pixels[(y + 1) * rowSize + (x * 3) + BLUE] + pixels[(y - 1) * rowSize + (x * 3) + BLUE]) / 2;
        .    .    .         .     .     .      .    .    .
   97,028    0    0    97,028     0     0      0    0    0              x++;
        .    .    .         .     .     .      .    .    .
        .    .    .         .     .     .      .    .    .              // R pixel
1,164,336    1    1   388,112     0     0 97,028    0    0              px = &pixels[y * rowSize + x * 3];
        .    .    .         .     .     .      .    .    .
        .    .    .         .     .     .      .    .    .              // Green channel derived form four adjacent green pixels
  291,084    0    0    97,028     0     0 97,028    0    0              px[GREEN] = (
1,649,476    1    1   485,140 6,092 6,092      0    0    0                  pixels[(y + 1) * rowSize + (x * 3) + GREEN] +
1,552,448    0    0   485,140     0     0      0    0    0                  pixels[(y - 1) * rowSize + (x * 3) + GREEN] +
1,552,448    1    1   485,140     0     0      0    0    0                  pixels[y * rowSize + ((x - 1) * 3) + GREEN] +
1,358,392    1    1   485,140     0     0      0    0    0                  pixels[y * rowSize + ((x + 1) * 3) + GREEN]
  388,112    0    0         0     0     0      0    0    0              ) / 4;
        .    .    .         .     .     .      .    .    .
        .    .    .         .     .     .      .    .    .              // Blue channel derived from four diagonal neighbouring blue pixels
  291,084    0    0    97,028     0     0 97,028    0    0              px[BLUE] = (
1,649,476    1    1   485,140     0     0      0    0    0                  pixels[(y + 1) * rowSize + ((x - 1) * 3) + BLUE] +
1,552,448    0    0   485,140 3,045 3,045      0    0    0                  pixels[(y + 1) * rowSize + ((x + 1) * 3) + BLUE] +
1,552,448    1    1   485,140     0     0      0    0    0                  pixels[(y - 1) * rowSize + ((x - 1) * 3) + BLUE] +
1,358,392    0    0   485,140     0     0      0    0    0                  pixels[(y - 1) * rowSize + ((x + 1) * 3) + BLUE]
  388,112    0    0         0     0     0      0    0    0              ) / 4;
        .    .    .         .     .     .      .    .    .          }
        .    .    .         .     .     .      .    .    .
      382    0    0       382     0     0      0    0    0          y++;
  393,078    0    0   294,140     0     0    382    0    0          for (x = 0; x < infoHeader.width; x ++) {
        .    .    .         .     .     .      .    .    .              // B pixel
1,173,504    1    1   391,168     0     0 97,792    0    0              px = &pixels[y * rowSize + x * 3];
        .    .    .         .     .     .      .    .    .
        .    .    .         .     .     .      .    .    .              // Red channel derived from four diagonal neighbouring red pixels
  293,376    0    0    97,792     0     0 97,792    0    0              px[RED] = (
1,760,256    1    1   488,960     0     0      0    0    0                  pixels[(y + 1) * rowSize + ((x - 1) * 3) + RED] +
1,662,464    0    0   488,960 9,144 9,144      0    0    0                  pixels[(y + 1) * rowSize + ((x + 1) * 3) + RED] +
1,662,464    1    1   488,960     0     0      0    0    0                  pixels[(y - 1) * rowSize + ((x - 1) * 3) + RED] +
1,466,880    1    1   488,960     0     0      0    0    0                  pixels[(y - 1) * rowSize + ((x + 1) * 3) + RED]
  391,168    0    0         0     0     0      0    0    0              ) / 4;
        .    .    .         .     .     .      .    .    .
        .    .    .         .     .     .      .    .    .              // Green channel derived form four adjacent green pixels
  293,376    0    0    97,792     0     0 97,792    0    0              px[GREEN] = (
1,662,464    2    2   488,960     0     0      0    0    0                  pixels[(y + 1) * rowSize + (x * 3) + GREEN] +
1,564,672    0    0   488,960     0     0      0    0    0                  pixels[(y - 1) * rowSize + (x * 3) + GREEN] +
1,564,672    0    0   488,960     0     0      0    0    0                  pixels[y * rowSize + ((x - 1) * 3) + GREEN] +
1,369,088    1    1   488,960     0     0      0    0    0                  pixels[y * rowSize + ((x + 1) * 3) + GREEN]
  391,168    0    0         0     0     0      0    0    0              ) / 4;
        .    .    .         .     .     .      .    .    .
   97,792    0    0    97,792     0     0      0    0    0              x++;
        .    .    .         .     .     .      .    .    .
        .    .    .         .     .     .      .    .    .              // Gb pixel
1,173,504    1    1   391,168     0     0 97,792    0    0              px = &pixels[y * rowSize + x * 3];
        .    .    .         .     .     .      .    .    .
        .    .    .         .     .     .      .    .    .              // Red channel derived from above and below pixels
3,716,096    1    1 1,075,712     0     0 97,792    0    0              px[RED] = (pixels[(y + 1) * rowSize + (x * 3) + RED] + pixels[(y - 1) * rowSize + (x * 3) + RED]) / 2;
        .    .    .         .     .     .      .    .    .
        .    .    .         .     .     .      .    .    .              // Blue channel derived from left and right pixels
3,520,512    1    1 1,075,712     0     0 97,792    0    0              px[BLUE] = (pixels[y * rowSize + ((x - 1) * 3) + BLUE] + pixels[y * rowSize + ((x + 1) * 3) + BLUE]) / 2;
        .    .    .         .     .     .      .    .    .          }
        .    .    .         .     .     .      .    .    .      }
        .    .    .         .     .     .      .    .    .
        .    .    .         .     .     .      .    .    .      // Create a new output file to write the modified image
        4    1    1         0     0     0      2    0    0      FILE *outFp = fopen("./decoded.bmp", "wb");
        2    0    0         1     0     0      0    0    0      if (!outFp) {
        .    .    .         .     .     .      .    .    .          printf("Error creating output file.\n");
        .    .    .         .     .     .      .    .    .          free(pixels);
        .    .    .         .     .     .      .    .    .          return 1;
        .    .    .         .     .     .      .    .    .      }
        .    .    .         .     .     .      .    .    .
        .    .    .         .     .     .      .    .    .      // Write the BMP header and information header
        7    1    1         1     0     0      1    0    0      fwrite(&header, sizeof(BMPHeader), 1, outFp);
        7    0    0         1     0     0      1    0    0      fwrite(&infoHeader, sizeof(BMPInfoHeader), 1, outFp);
        .    .    .         .     .     .      .    .    .
        .    .    .         .     .     .      .    .    .      // Write the modified pixel data
        9    0    0         4     0     0      1    0    0      fwrite(pixels, rowSize * infoHeader.height, 1, outFp);
        .    .    .         .     .     .      .    .    .
        .    .    .         .     .     .      .    .    .      // Clean up
        3    0    0         1     0     0      1    0    0      free(pixels);
        3    0    0         1     0     0      1    0    0      fclose(outFp);
        .    .    .         .     .     .      .    .    .
        1    0    0         0     0     0      0    0    0      return 0;
        2    0    0         2     1     0      0    0    0  }

--------------------------------------------------------------------------------
Ir         I1mr ILmr Dr         D1mr   DLmr   Dw        D1mw DLmw
--------------------------------------------------------------------------------
47,836,048   28   28 14,809,402 18,282 18,281 1,169,702    1    0  events annotated
