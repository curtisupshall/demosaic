==26374== Cachegrind, a cache and branch-prediction profiler
==26374== Copyright (C) 2002-2017, and GNU GPL'd, by Nicholas Nethercote et al.
==26374== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info
==26374== Command: ./metric.exe
==26374==
--26374-- warning: L3 cache found, using its data for the LL simulation.
==26374==
==26374== I   refs:      2,942,790,752
==26374== I1  misses:              973
==26374== LLi misses:              969
==26374== I1  miss rate:          0.00%
==26374== LLi miss rate:          0.00%
==26374==
==26374== D   refs:        982,944,234  (911,004,933 rd   + 71,939,301 wr)
==26374== D1  misses:        1,198,566  (  1,191,772 rd   +      6,794 wr)
==26374== LLd misses:        1,127,809  (  1,126,965 rd   +        844 wr)
==26374== D1  miss rate:           0.1% (        0.1%     +        0.0%  )
==26374== LLd miss rate:           0.1% (        0.1%     +        0.0%  )
==26374==
==26374== LL refs:           1,199,539  (  1,192,745 rd   +      6,794 wr)
==26374== LL misses:         1,128,778  (  1,127,934 rd   +        844 wr)
==26374== LL miss rate:            0.0% (        0.0%     +        0.0%  )

--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         8388608 B, 64 B, 16-way associative
Command:          ./metric.exe
Data file:        cachegrind.out.26374
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:
User annotated:
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir            I1mr ILmr Dr          D1mr      DLmr      Dw         D1mw  DLmw
--------------------------------------------------------------------------------
2,942,790,752  973  969 911,004,933 1,191,772 1,126,965 71,939,301 6,794  844  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir            I1mr ILmr Dr          D1mr      DLmr      Dw         D1mw  DLmw  file:function
--------------------------------------------------------------------------------
2,942,624,040   28   28 910,960,314 1,188,981 1,124,627 71,922,038 5,903    0  /tmp/demosaic440/decode.c:main

--------------------------------------------------------------------------------
-- Auto-annotated source: /tmp/demosaic440/decode.c
--------------------------------------------------------------------------------
Ir          I1mr ILmr Dr         D1mr    DLmr    Dw        D1mw  DLmw

-- line 25 ----------------------------------------
          .    .    .          .       .       .         .     .    .      uint32_t imageSize;
          .    .    .          .       .       .         .     .    .      int32_t xResolution;
          .    .    .          .       .       .         .     .    .      int32_t yResolution;
          .    .    .          .       .       .         .     .    .      uint32_t colorsUsed;
          .    .    .          .       .       .         .     .    .      uint32_t colorsImportant;
          .    .    .          .       .       .         .     .    .  } BMPInfoHeader;
          .    .    .          .       .       .         .     .    .  #pragma pack(pop)
          .    .    .          .       .       .         .     .    .
          3    0    0          0       0       0         1     0    0  int main() {
          4    0    0          0       0       0         2     1    0      FILE *fp = fopen("./encoded.bmp", "rb");
          2    0    0          1       0       0         0     0    0      if (!fp) {
          .    .    .          .       .       .         .     .    .          printf("Error opening file.\n");
          .    .    .          .       .       .         .     .    .          return 1;
          .    .    .          .       .       .         .     .    .      }
          .    .    .          .       .       .         .     .    .
          .    .    .          .       .       .         .     .    .      BMPHeader header;
          .    .    .          .       .       .         .     .    .      BMPInfoHeader infoHeader;
          .    .    .          .       .       .         .     .    .
          .    .    .          .       .       .         .     .    .      // Read the BMP header
          7    1    1          1       0       0         1     0    0      fread(&header, sizeof(BMPHeader), 1, fp);
          7    1    1          1       0       0         1     0    0      fread(&infoHeader, sizeof(BMPInfoHeader), 1, fp);
          .    .    .          .       .       .         .     .    .
          .    .    .          .       .       .         .     .    .      // Check if it's a valid BMP file
          3    0    0          1       0       0         0     0    0      if (header.type != 0x4D42) {
          .    .    .          .       .       .         .     .    .          printf("Invalid BMP file.\n");
          .    .    .          .       .       .         .     .    .          fclose(fp);
          .    .    .          .       .       .         .     .    .          return 1;
          .    .    .          .       .       .         .     .    .      }
          .    .    .          .       .       .         .     .    .
          .    .    .          .       .       .         .     .    .      // Check if it's a 24-bit BMP file
          3    1    1          1       0       0         0     0    0      if (infoHeader.bitDepth != 24) {
          .    .    .          .       .       .         .     .    .          printf("Unsupported bit depth. Only 24-bit BMP is supported.\n");
          .    .    .          .       .       .         .     .    .          fclose(fp);
          .    .    .          .       .       .         .     .    .          return 1;
          .    .    .          .       .       .         .     .    .      }
          .    .    .          .       .       .         .     .    .
          .    .    .          .       .       .         .     .    .      // Calculate the row size in bytes (including padding)
          7    0    0          1       0       0         1     0    0      uint32_t rowSize = ((infoHeader.width * 3 + 3) & ~3);
          .    .    .          .       .       .         .     .    .
          .    .    .          .       .       .         .     .    .      // Allocate memory for the pixel data
          6    1    1          2       0       0         2     0    0      uint8_t *pixels = (uint8_t*)malloc(rowSize * infoHeader.height);
          .    .    .          .       .       .         .     .    .
          .    .    .          .       .       .         .     .    .      // Read the pixel data
          9    0    0          4       0       0         1     0    0      fread(pixels, rowSize * infoHeader.height, 1, fp);
          .    .    .          .       .       .         .     .    .
          3    0    0          1       0       0         1     0    0      fclose(fp);
          .    .    .          .       .       .         .     .    .
          .    .    .          .       .       .         .     .    .      uint8_t *px;
          .    .    .          .       .       .         .     .    .
          .    .    .          .       .       .         .     .    .      int y, x;
          .    .    .          .       .       .         .     .    .      // Access pixel values
     14,996    2    2      8,996       0       0         1     0    0      for (y = 2; y < infoHeader.height - 2; y++) {
 29,968,008    1    1 17,976,008       0       0     2,998     0    0          for (x = 2; x < infoHeader.width - 2; x ++) {
          .    .    .          .       .       .         .     .    .              // Gr pixel
 71,880,048    0    0 23,960,016       0       0 5,990,004     0    0              px = &pixels[y * rowSize + x * 3];
          .    .    .          .       .       .         .     .    .
          .    .    .          .       .       .         .     .    .              // Red channel derived from left and right pixels
227,620,152    2    2 65,890,044  11,740     125 5,990,004     0    0              px[RED] = (pixels[y * rowSize + ((x - 1) * 3) + RED] + pixels[y * rowSize + ((x + 1) * 3) + RED]) / 2;
          .    .    .          .       .       .         .     .    .
          .    .    .          .       .       .         .     .    .              // Blue channel derived from above and below pixels
215,640,144    1    1 65,890,044       2       2 5,990,004     0    0              px[BLUE] = (pixels[(y + 1) * rowSize + (x * 3) + BLUE] + pixels[(y - 1) * rowSize + (x * 3) + BLUE]) / 2;
          .    .    .          .       .       .         .     .    .
  5,990,004    0    0  5,990,004       0       0         0     0    0              x++;
          .    .    .          .       .       .         .     .    .
          .    .    .          .       .       .         .     .    .              // R pixel
 71,880,048    1    1 23,960,016       0       0 5,990,004     0    0              px = &pixels[y * rowSize + x * 3];
          .    .    .          .       .       .         .     .    .
          .    .    .          .       .       .         .     .    .              // Green channel derived form four adjacent green pixels
 17,970,012    0    0  5,990,004       0       0 5,990,004     0    0              px[GREEN] = (
101,830,068    1    1 29,950,020 377,748 377,748         0     0    0                  pixels[(y + 1) * rowSize + (x * 3) + GREEN] +
 95,840,064    0    0 29,950,020  11,925     125         0     0    0                  pixels[(y - 1) * rowSize + (x * 3) + GREEN] +
 95,840,064    1    1 29,950,020       0       0         0     0    0                  pixels[y * rowSize + ((x - 1) * 3) + GREEN] +
 83,860,056    1    1 29,950,020   5,962      62         0     0    0                  pixels[y * rowSize + ((x + 1) * 3) + GREEN]
 23,960,016    0    0          0       0       0         0     0    0              ) / 4;
          .    .    .          .       .       .         .     .    .
          .    .    .          .       .       .         .     .    .              // Blue channel derived from four diagonal neighbouring blue pixels
 17,970,012    0    0  5,990,004       0       0 5,990,004     0    0              px[BLUE] = (
101,830,068    1    1 29,950,020       0       0         0     0    0                  pixels[(y + 1) * rowSize + ((x - 1) * 3) + BLUE] +
 95,840,064    0    0 29,950,020 185,876 185,876         0     0    0                  pixels[(y + 1) * rowSize + ((x + 1) * 3) + BLUE] +
 95,840,064    1    1 29,950,020       0       0         0     0    0                  pixels[(y - 1) * rowSize + ((x - 1) * 3) + BLUE] +
 83,860,056    0    0 29,950,020   5,869      62         0     0    0                  pixels[(y - 1) * rowSize + ((x + 1) * 3) + BLUE]
 23,960,016    0    0          0       0       0         0     0    0              ) / 4;
          .    .    .          .       .       .         .     .    .          }
          .    .    .          .       .       .         .     .    .
      2,998    0    0      2,998       0       0         0     0    0          y++;
 23,998,990    0    0 17,993,996       0       0     2,998     0    0          for (x = 0; x < infoHeader.width; x ++) {
          .    .    .          .       .       .         .     .    .              // B pixel
 71,952,000    1    1 23,984,000       0       0 5,996,000     0    0              px = &pixels[y * rowSize + x * 3];
          .    .    .          .       .       .         .     .    .
          .    .    .          .       .       .         .     .    .              // Red channel derived from four diagonal neighbouring red pixels
 17,988,000    0    0  5,996,000       0       0 5,996,000 5,902    0              px[RED] = (
107,928,000    1    1 29,980,000       0       0         0     0    0                  pixels[(y + 1) * rowSize + ((x - 1) * 3) + RED] +
101,932,000    0    0 29,980,000 560,626 560,626         0     0    0                  pixels[(y + 1) * rowSize + ((x + 1) * 3) + RED] +
101,932,000    1    1 29,980,000       0       0         0     0    0                  pixels[(y - 1) * rowSize + ((x - 1) * 3) + RED] +
 89,940,000    1    1 29,980,000  17,521       0         0     0    0                  pixels[(y - 1) * rowSize + ((x + 1) * 3) + RED]
 23,984,000    0    0          0       0       0         0     0    0              ) / 4;
          .    .    .          .       .       .         .     .    .
          .    .    .          .       .       .         .     .    .              // Green channel derived form four adjacent green pixels
 17,988,000    0    0  5,996,000       0       0 5,996,000     0    0              px[GREEN] = (
101,932,000    2    2 29,980,000       0       0         0     0    0                  pixels[(y + 1) * rowSize + (x * 3) + GREEN] +
 95,936,000    0    0 29,980,000       0       0         0     0    0                  pixels[(y - 1) * rowSize + (x * 3) + GREEN] +
 95,936,000    0    0 29,980,000       0       0         0     0    0                  pixels[y * rowSize + ((x - 1) * 3) + GREEN] +
 83,944,000    1    1 29,980,000   5,902       0         0     0    0                  pixels[y * rowSize + ((x + 1) * 3) + GREEN]
 23,984,000    0    0          0       0       0         0     0    0              ) / 4;
          .    .    .          .       .       .         .     .    .
  5,996,000    0    0  5,996,000       0       0         0     0    0              x++;
          .    .    .          .       .       .         .     .    .
          .    .    .          .       .       .         .     .    .              // Gb pixel
 71,952,000    1    1 23,984,000       0       0 5,996,000     0    0              px = &pixels[y * rowSize + x * 3];
          .    .    .          .       .       .         .     .    .
          .    .    .          .       .       .         .     .    .              // Red channel derived from above and below pixels
227,848,000    1    1 65,956,000       0       0 5,996,000     0    0              px[RED] = (pixels[(y + 1) * rowSize + (x * 3) + RED] + pixels[(y - 1) * rowSize + (x * 3) + RED]) / 2;
          .    .    .          .       .       .         .     .    .
          .    .    .          .       .       .         .     .    .              // Blue channel derived from left and right pixels
215,856,000    1    1 65,956,000   5,809       0 5,996,000     0    0              px[BLUE] = (pixels[y * rowSize + ((x - 1) * 3) + BLUE] + pixels[y * rowSize + ((x + 1) * 3) + BLUE]) / 2;
          .    .    .          .       .       .         .     .    .          }
          .    .    .          .       .       .         .     .    .      }
          .    .    .          .       .       .         .     .    .
          .    .    .          .       .       .         .     .    .      // Create a new output file to write the modified image
          4    1    1          0       0       0         2     0    0      FILE *outFp = fopen("./decoded.bmp", "wb");
          2    0    0          1       0       0         0     0    0      if (!outFp) {
          .    .    .          .       .       .         .     .    .          printf("Error creating output file.\n");
          .    .    .          .       .       .         .     .    .          free(pixels);
          .    .    .          .       .       .         .     .    .          return 1;
          .    .    .          .       .       .         .     .    .      }
          .    .    .          .       .       .         .     .    .
          .    .    .          .       .       .         .     .    .      // Write the BMP header and information header
          7    1    1          1       0       0         1     0    0      fwrite(&header, sizeof(BMPHeader), 1, outFp);
          7    0    0          1       0       0         1     0    0      fwrite(&infoHeader, sizeof(BMPInfoHeader), 1, outFp);
          .    .    .          .       .       .         .     .    .
          .    .    .          .       .       .         .     .    .      // Write the modified pixel data
          9    0    0          4       0       0         1     0    0      fwrite(pixels, rowSize * infoHeader.height, 1, outFp);
          .    .    .          .       .       .         .     .    .
          .    .    .          .       .       .         .     .    .      // Clean up
          3    0    0          1       0       0         1     0    0      free(pixels);
          3    0    0          1       0       0         1     0    0      fclose(outFp);
          .    .    .          .       .       .         .     .    .
          1    0    0          0       0       0         0     0    0      return 0;
          2    0    0          2       1       1         0     0    0  }

--------------------------------------------------------------------------------
Ir            I1mr ILmr Dr          D1mr      DLmr      Dw         D1mw  DLmw
--------------------------------------------------------------------------------
2,942,624,040   28   28 910,960,314 1,188,981 1,124,627 71,922,038 5,903    0  events annotated
