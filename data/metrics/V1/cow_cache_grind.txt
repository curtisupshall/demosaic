==22811== Cachegrind, a cache and branch-prediction profiler
==22811== Copyright (C) 2002-2017, and GNU GPL'd, by Nicholas Nethercote et al.
==22811== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info
==22811== Command: ./metric.exe
==22811==
--22811-- warning: L3 cache found, using its data for the LL simulation.
==22811==
==22811== I   refs:      39,987,949
==22811== I1  misses:           973
==22811== LLi misses:           967
==22811== I1  miss rate:       0.00%
==22811== LLi miss rate:       0.00%
==22811==
==22811== D   refs:      13,363,593  (12,372,729 rd   + 990,864 wr)
==22811== D1  misses:        18,874  (    17,990 rd   +     884 wr)
==22811== LLd misses:        17,954  (    17,280 rd   +     674 wr)
==22811== D1  miss rate:        0.1% (       0.1%     +     0.1%  )
==22811== LLd miss rate:        0.1% (       0.1%     +     0.1%  )
==22811==
==22811== LL refs:           19,847  (    18,963 rd   +     884 wr)
==22811== LL misses:         18,921  (    18,247 rd   +     674 wr)
==22811== LL miss rate:         0.0% (       0.0%     +     0.1%  )

--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         8388608 B, 64 B, 16-way associative
Command:          ./metric.exe
Data file:        cachegrind.out.22811
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:
User annotated:
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir         I1mr ILmr Dr         D1mr   DLmr   Dw      D1mw DLmw
--------------------------------------------------------------------------------
39,987,949  973  967 12,372,729 17,990 17,280 990,864  884  674  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir         I1mr ILmr Dr         D1mr   DLmr   Dw      D1mw DLmw  file:function
--------------------------------------------------------------------------------
39,821,648   28   28 12,328,250 15,210 15,209 973,734    1    0  /tmp/demosaic440/decode.c:main
    56,525   10   10     13,788  1,029    863      16    3    0  ???:_dl_addr

--------------------------------------------------------------------------------
-- Auto-annotated source: /tmp/demosaic440/decode.c
--------------------------------------------------------------------------------
Ir        I1mr ILmr Dr      D1mr  DLmr  Dw     D1mw DLmw

-- line 25 ----------------------------------------
        .    .    .       .     .     .      .    .    .      uint32_t imageSize;
        .    .    .       .     .     .      .    .    .      int32_t xResolution;
        .    .    .       .     .     .      .    .    .      int32_t yResolution;
        .    .    .       .     .     .      .    .    .      uint32_t colorsUsed;
        .    .    .       .     .     .      .    .    .      uint32_t colorsImportant;
        .    .    .       .     .     .      .    .    .  } BMPInfoHeader;
        .    .    .       .     .     .      .    .    .  #pragma pack(pop)
        .    .    .       .     .     .      .    .    .
        3    0    0       0     0     0      1    0    0  int main() {
        4    0    0       0     0     0      2    1    0      FILE *fp = fopen("./encoded.bmp", "rb");
        2    0    0       1     0     0      0    0    0      if (!fp) {
        .    .    .       .     .     .      .    .    .          printf("Error opening file.\n");
        .    .    .       .     .     .      .    .    .          return 1;
        .    .    .       .     .     .      .    .    .      }
        .    .    .       .     .     .      .    .    .
        .    .    .       .     .     .      .    .    .      BMPHeader header;
        .    .    .       .     .     .      .    .    .      BMPInfoHeader infoHeader;
        .    .    .       .     .     .      .    .    .
        .    .    .       .     .     .      .    .    .      // Read the BMP header
        7    1    1       1     0     0      1    0    0      fread(&header, sizeof(BMPHeader), 1, fp);
        7    1    1       1     0     0      1    0    0      fread(&infoHeader, sizeof(BMPInfoHeader), 1, fp);
        .    .    .       .     .     .      .    .    .
        .    .    .       .     .     .      .    .    .      // Check if it's a valid BMP file
        3    0    0       1     0     0      0    0    0      if (header.type != 0x4D42) {
        .    .    .       .     .     .      .    .    .          printf("Invalid BMP file.\n");
        .    .    .       .     .     .      .    .    .          fclose(fp);
        .    .    .       .     .     .      .    .    .          return 1;
        .    .    .       .     .     .      .    .    .      }
        .    .    .       .     .     .      .    .    .
        .    .    .       .     .     .      .    .    .      // Check if it's a 24-bit BMP file
        3    1    1       1     0     0      0    0    0      if (infoHeader.bitDepth != 24) {
        .    .    .       .     .     .      .    .    .          printf("Unsupported bit depth. Only 24-bit BMP is supported.\n");
        .    .    .       .     .     .      .    .    .          fclose(fp);
        .    .    .       .     .     .      .    .    .          return 1;
        .    .    .       .     .     .      .    .    .      }
        .    .    .       .     .     .      .    .    .
        .    .    .       .     .     .      .    .    .      // Calculate the row size in bytes (including padding)
        7    0    0       1     0     0      1    0    0      uint32_t rowSize = ((infoHeader.width * 3 + 3) & ~3);
        .    .    .       .     .     .      .    .    .
        .    .    .       .     .     .      .    .    .      // Allocate memory for the pixel data
        6    1    1       2     0     0      2    0    0      uint8_t *pixels = (uint8_t*)malloc(rowSize * infoHeader.height);
        .    .    .       .     .     .      .    .    .
        .    .    .       .     .     .      .    .    .      // Read the pixel data
        9    0    0       4     0     0      1    0    0      fread(pixels, rowSize * infoHeader.height, 1, fp);
        .    .    .       .     .     .      .    .    .
        3    0    0       1     0     0      1    0    0      fclose(fp);
        .    .    .       .     .     .      .    .    .
        .    .    .       .     .     .      .    .    .      uint8_t *px;
        .    .    .       .     .     .      .    .    .
        .    .    .       .     .     .      .    .    .      int y, x;
        .    .    .       .     .     .      .    .    .      // Access pixel values
    1,596    2    2     956     0     0      1    0    0      for (y = 2; y < infoHeader.height - 2; y++) {
  405,768    1    1 242,952     0     0    318    0    0          for (x = 2; x < infoHeader.width - 2; x ++) {
        .    .    .       .     .     .      .    .    .              // Gr pixel
  969,264    0    0 323,088     0     0 80,772    0    0              px = &pixels[y * rowSize + x * 3];
        .    .    .       .     .     .      .    .    .
        .    .    .       .     .     .      .    .    .              // Red channel derived from left and right pixels
3,069,336    2    2 888,492     0     0 80,772    0    0              px[RED] = (pixels[y * rowSize + ((x - 1) * 3) + RED] + pixels[y * rowSize + ((x + 1) * 3) + RED]) / 2;
        .    .    .       .     .     .      .    .    .
        .    .    .       .     .     .      .    .    .              // Blue channel derived from above and below pixels
2,907,792    1    1 888,492     0     0 80,772    0    0              px[BLUE] = (pixels[(y + 1) * rowSize + (x * 3) + BLUE] + pixels[(y - 1) * rowSize + (x * 3) + BLUE]) / 2;
        .    .    .       .     .     .      .    .    .
   80,772    0    0  80,772     0     0      0    0    0              x++;
        .    .    .       .     .     .      .    .    .
        .    .    .       .     .     .      .    .    .              // R pixel
  969,264    1    1 323,088     0     0 80,772    0    0              px = &pixels[y * rowSize + x * 3];
        .    .    .       .     .     .      .    .    .
        .    .    .       .     .     .      .    .    .              // Green channel derived form four adjacent green pixels
  242,316    0    0  80,772     0     0 80,772    0    0              px[GREEN] = (
1,373,124    1    1 403,860 5,068 5,068      0    0    0                  pixels[(y + 1) * rowSize + (x * 3) + GREEN] +
1,292,352    0    0 403,860     0     0      0    0    0                  pixels[(y - 1) * rowSize + (x * 3) + GREEN] +
1,292,352    1    1 403,860     0     0      0    0    0                  pixels[y * rowSize + ((x - 1) * 3) + GREEN] +
1,130,808    1    1 403,860     0     0      0    0    0                  pixels[y * rowSize + ((x + 1) * 3) + GREEN]
  323,088    0    0       0     0     0      0    0    0              ) / 4;
        .    .    .       .     .     .      .    .    .
        .    .    .       .     .     .      .    .    .              // Blue channel derived from four diagonal neighbouring blue pixels
  242,316    0    0  80,772     0     0 80,772    0    0              px[BLUE] = (
1,373,124    1    1 403,860     0     0      0    0    0                  pixels[(y + 1) * rowSize + ((x - 1) * 3) + BLUE] +
1,292,352    0    0 403,860 2,533 2,533      0    0    0                  pixels[(y + 1) * rowSize + ((x + 1) * 3) + BLUE] +
1,292,352    1    1 403,860     0     0      0    0    0                  pixels[(y - 1) * rowSize + ((x - 1) * 3) + BLUE] +
1,130,808    0    0 403,860     0     0      0    0    0                  pixels[(y - 1) * rowSize + ((x + 1) * 3) + BLUE]
  323,088    0    0       0     0     0      0    0    0              ) / 4;
        .    .    .       .     .     .      .    .    .          }
        .    .    .       .     .     .      .    .    .
      318    0    0     318     0     0      0    0    0          y++;
  327,222    0    0 244,860     0     0    318    0    0          for (x = 0; x < infoHeader.width; x ++) {
        .    .    .       .     .     .      .    .    .              // B pixel
  976,896    1    1 325,632     0     0 81,408    0    0              px = &pixels[y * rowSize + x * 3];
        .    .    .       .     .     .      .    .    .
        .    .    .       .     .     .      .    .    .              // Red channel derived from four diagonal neighbouring red pixels
  244,224    0    0  81,408     0     0 81,408    0    0              px[RED] = (
1,465,344    1    1 407,040     0     0      0    0    0                  pixels[(y + 1) * rowSize + ((x - 1) * 3) + RED] +
1,383,936    0    0 407,040 7,608 7,608      0    0    0                  pixels[(y + 1) * rowSize + ((x + 1) * 3) + RED] +
1,383,936    1    1 407,040     0     0      0    0    0                  pixels[(y - 1) * rowSize + ((x - 1) * 3) + RED] +
1,221,120    1    1 407,040     0     0      0    0    0                  pixels[(y - 1) * rowSize + ((x + 1) * 3) + RED]
  325,632    0    0       0     0     0      0    0    0              ) / 4;
        .    .    .       .     .     .      .    .    .
        .    .    .       .     .     .      .    .    .              // Green channel derived form four adjacent green pixels
  244,224    0    0  81,408     0     0 81,408    0    0              px[GREEN] = (
1,383,936    2    2 407,040     0     0      0    0    0                  pixels[(y + 1) * rowSize + (x * 3) + GREEN] +
1,302,528    0    0 407,040     0     0      0    0    0                  pixels[(y - 1) * rowSize + (x * 3) + GREEN] +
1,302,528    0    0 407,040     0     0      0    0    0                  pixels[y * rowSize + ((x - 1) * 3) + GREEN] +
1,139,712    1    1 407,040     0     0      0    0    0                  pixels[y * rowSize + ((x + 1) * 3) + GREEN]
  325,632    0    0       0     0     0      0    0    0              ) / 4;
        .    .    .       .     .     .      .    .    .
   81,408    0    0  81,408     0     0      0    0    0              x++;
        .    .    .       .     .     .      .    .    .
        .    .    .       .     .     .      .    .    .              // Gb pixel
  976,896    1    1 325,632     0     0 81,408    0    0              px = &pixels[y * rowSize + x * 3];
        .    .    .       .     .     .      .    .    .
        .    .    .       .     .     .      .    .    .              // Red channel derived from above and below pixels
3,093,504    1    1 895,488     0     0 81,408    0    0              px[RED] = (pixels[(y + 1) * rowSize + (x * 3) + RED] + pixels[(y - 1) * rowSize + (x * 3) + RED]) / 2;
        .    .    .       .     .     .      .    .    .
        .    .    .       .     .     .      .    .    .              // Blue channel derived from left and right pixels
2,930,688    1    1 895,488     0     0 81,408    0    0              px[BLUE] = (pixels[y * rowSize + ((x - 1) * 3) + BLUE] + pixels[y * rowSize + ((x + 1) * 3) + BLUE]) / 2;
        .    .    .       .     .     .      .    .    .          }
        .    .    .       .     .     .      .    .    .      }
        .    .    .       .     .     .      .    .    .
        .    .    .       .     .     .      .    .    .      // Create a new output file to write the modified image
        4    1    1       0     0     0      2    0    0      FILE *outFp = fopen("./decoded.bmp", "wb");
        2    0    0       1     0     0      0    0    0      if (!outFp) {
        .    .    .       .     .     .      .    .    .          printf("Error creating output file.\n");
        .    .    .       .     .     .      .    .    .          free(pixels);
        .    .    .       .     .     .      .    .    .          return 1;
        .    .    .       .     .     .      .    .    .      }
        .    .    .       .     .     .      .    .    .
        .    .    .       .     .     .      .    .    .      // Write the BMP header and information header
        7    1    1       1     0     0      1    0    0      fwrite(&header, sizeof(BMPHeader), 1, outFp);
        7    0    0       1     0     0      1    0    0      fwrite(&infoHeader, sizeof(BMPInfoHeader), 1, outFp);
        .    .    .       .     .     .      .    .    .
        .    .    .       .     .     .      .    .    .      // Write the modified pixel data
        9    0    0       4     0     0      1    0    0      fwrite(pixels, rowSize * infoHeader.height, 1, outFp);
        .    .    .       .     .     .      .    .    .
        .    .    .       .     .     .      .    .    .      // Clean up
        3    0    0       1     0     0      1    0    0      free(pixels);
        3    0    0       1     0     0      1    0    0      fclose(outFp);
        .    .    .       .     .     .      .    .    .
        1    0    0       0     0     0      0    0    0      return 0;
        2    0    0       2     1     0      0    0    0  }

--------------------------------------------------------------------------------
Ir         I1mr ILmr Dr         D1mr   DLmr   Dw      D1mw DLmw
--------------------------------------------------------------------------------
39,821,648   28   28 12,328,250 15,210 15,209 973,734    1    0  events annotated
